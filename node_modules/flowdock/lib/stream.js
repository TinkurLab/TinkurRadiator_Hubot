// Generated by CoffeeScript 1.8.0
(function() {
  var JSONStream, Stream, backoff, baseURL, request, url,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  url = require('url');

  request = require('request');

  JSONStream = require('./json_stream');

  baseURL = function() {
    return url.parse(process.env.FLOWDOCK_STREAM_URL || 'https://stream.flowdock.com/flows');
  };

  backoff = function(backoff, errors, operator) {
    if (operator == null) {
      operator = '*';
    }
    return Math.min(backoff.max, (operator === '+' ? errors : Math.pow(2, errors - 1)) * backoff.delay);
  };

  Stream = (function(_super) {
    __extends(Stream, _super);

    function Stream(auth, flows, params) {
      this.auth = auth;
      this.flows = flows;
      this.params = params != null ? params : {};
      this.networkErrors = 0;
      this.responseErrors = 0;
      this.on('reconnecting', (function(_this) {
        return function(timeout) {
          return setTimeout(function() {
            return _this.connect();
          }, timeout);
        };
      })(this));
    }

    Stream.prototype.connect = function() {
      var errorHandler;
      if (this.disconnecting) {
        return;
      }
      errorHandler = (function(_this) {
        return function(error) {
          _this.networkErrors += 1;
          _this.emit('clientError', 0, 'Network error');
          return _this.emit('reconnecting', backoff(Stream.backoff.network, _this.networkErrors, '+'));
        };
      })(this);
      this.request = request(this.options()).on('response', (function(_this) {
        return function(response) {
          var parser;
          _this.request.removeListener('error', errorHandler);
          _this.networkErrors = 0;
          if (response.statusCode >= 400) {
            _this.responseErrors += 1;
            _this.emit('clientError', response.statusCode);
            return _this.emit('reconnecting', backoff(Stream.backoff.error, _this.responseErrors, '*'));
          } else {
            _this.responseErrors = 0;
            parser = new JSONStream();
            parser.on('data', function(message) {
              return _this.emit('message', message);
            });
            _this.request.on('abort', function() {
              parser.removeAllListeners();
              _this.emit('disconnected');
              return _this.emit('end');
            });
            parser.on('end', function() {
              parser.removeAllListeners();
              _this.emit('disconnected');
              _this.emit('clientError', 0, 'Disconnected');
              return _this.emit('reconnecting', 0);
            });
            _this.request.pipe(parser);
            return _this.emit('connected');
          }
        };
      })(this));
      this.request.once('error', errorHandler);
      return this.request;
    };

    Stream.prototype.options = function() {
      var key, options, value, _ref;
      options = {
        uri: baseURL(),
        qs: {
          filter: this.flows.join(',')
        },
        method: 'GET',
        headers: {
          'Authorization': this.auth,
          'Accept': 'application/json'
        }
      };
      _ref = this.params;
      for (key in _ref) {
        value = _ref[key];
        options.qs[key] = value;
      }
      return options;
    };

    Stream.prototype.end = function() {
      this.disconnecting = true;
      if (this.request) {
        this.request.abort();
        this.request.removeAllListeners();
        return this.request = void 0;
      }
    };

    Stream.prototype.close = function() {
      console.warn('DEPRECATED, use Stream#end() instead');
      return this.end();
    };

    return Stream;

  })(process.EventEmitter);

  Stream.connect = function(auth, flows, params) {
    var stream;
    stream = new Stream(auth, flows, params);
    stream.connect();
    return stream;
  };

  Stream.backoff = {
    network: {
      delay: 200,
      max: 10000
    },
    error: {
      delay: 2000,
      max: 120000
    }
  };

  module.exports = Stream;

}).call(this);
